// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: shentu/oracle/v1alpha1/tx.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { Duration } from "../../../google/protobuf/duration";
import { Timestamp } from "../../../google/protobuf/timestamp";

export const protobufPackage = "shentu.oracle.v1alpha1";

export interface MsgCreateOperator {
  address: string;
  collateral: Coin[];
  proposer: string;
  name: string;
}

export interface MsgCreateOperatorResponse {
}

export interface MsgRemoveOperator {
  address: string;
  proposer: string;
}

export interface MsgRemoveOperatorResponse {
}

export interface MsgAddCollateral {
  address: string;
  collateralIncrement: Coin[];
}

export interface MsgAddCollateralResponse {
}

export interface MsgReduceCollateral {
  address: string;
  collateralDecrement: Coin[];
}

export interface MsgReduceCollateralResponse {
}

export interface MsgWithdrawReward {
  address: string;
}

export interface MsgWithdrawRewardResponse {
}

export interface MsgCreateTask {
  contract: string;
  function: string;
  bounty: Coin[];
  description: string;
  creator: string;
  wait: string;
  validDuration: Duration | undefined;
}

export interface MsgCreateTaskResponse {
}

export interface MsgTaskResponse {
  contract: string;
  function: string;
  score: string;
  operator: string;
}

export interface MsgTaskResponseResponse {
}

export interface MsgDeleteTask {
  contract: string;
  function: string;
  force: boolean;
  from: string;
}

export interface MsgDeleteTaskResponse {
}

export interface MsgCreateTxTask {
  creator: string;
  chainId: string;
  /** the bytes of application chain transaction that is going to be evaluated */
  atxBytes: Uint8Array;
  bounty: Coin[];
  validTime: Date | undefined;
}

export interface MsgCreateTxTaskResponse {
  /** sha256 hash of the application chain transaction */
  atxHash: Uint8Array;
}

export interface MsgTxTaskResponse {
  /** sha256 hash of the application chain transaction */
  atxHash: Uint8Array;
  score: string;
  operator: string;
}

export interface MsgTxTaskResponseResponse {
}

export interface MsgDeleteTxTask {
  /** sha256 hash of the application chain transaction */
  atxHash: Uint8Array;
  from: string;
}

export interface MsgDeleteTxTaskResponse {
}

function createBaseMsgCreateOperator(): MsgCreateOperator {
  return { address: "", collateral: [], proposer: "", name: "" };
}

export const MsgCreateOperator = {
  encode(message: MsgCreateOperator, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.collateral) {
      Coin.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.proposer !== "") {
      writer.uint32(26).string(message.proposer);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateOperator {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.collateral.push(Coin.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.proposer = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateOperator {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      collateral: globalThis.Array.isArray(object?.collateral)
        ? object.collateral.map((e: any) => Coin.fromJSON(e))
        : [],
      proposer: isSet(object.proposer) ? globalThis.String(object.proposer) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: MsgCreateOperator): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.collateral?.length) {
      obj.collateral = message.collateral.map((e) => Coin.toJSON(e));
    }
    if (message.proposer !== "") {
      obj.proposer = message.proposer;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateOperator>, I>>(base?: I): MsgCreateOperator {
    return MsgCreateOperator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateOperator>, I>>(object: I): MsgCreateOperator {
    const message = createBaseMsgCreateOperator();
    message.address = object.address ?? "";
    message.collateral = object.collateral?.map((e) => Coin.fromPartial(e)) || [];
    message.proposer = object.proposer ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMsgCreateOperatorResponse(): MsgCreateOperatorResponse {
  return {};
}

export const MsgCreateOperatorResponse = {
  encode(_: MsgCreateOperatorResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateOperatorResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateOperatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCreateOperatorResponse {
    return {};
  },

  toJSON(_: MsgCreateOperatorResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateOperatorResponse>, I>>(base?: I): MsgCreateOperatorResponse {
    return MsgCreateOperatorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateOperatorResponse>, I>>(_: I): MsgCreateOperatorResponse {
    const message = createBaseMsgCreateOperatorResponse();
    return message;
  },
};

function createBaseMsgRemoveOperator(): MsgRemoveOperator {
  return { address: "", proposer: "" };
}

export const MsgRemoveOperator = {
  encode(message: MsgRemoveOperator, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.proposer !== "") {
      writer.uint32(18).string(message.proposer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRemoveOperator {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.proposer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveOperator {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      proposer: isSet(object.proposer) ? globalThis.String(object.proposer) : "",
    };
  },

  toJSON(message: MsgRemoveOperator): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.proposer !== "") {
      obj.proposer = message.proposer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRemoveOperator>, I>>(base?: I): MsgRemoveOperator {
    return MsgRemoveOperator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRemoveOperator>, I>>(object: I): MsgRemoveOperator {
    const message = createBaseMsgRemoveOperator();
    message.address = object.address ?? "";
    message.proposer = object.proposer ?? "";
    return message;
  },
};

function createBaseMsgRemoveOperatorResponse(): MsgRemoveOperatorResponse {
  return {};
}

export const MsgRemoveOperatorResponse = {
  encode(_: MsgRemoveOperatorResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRemoveOperatorResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveOperatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveOperatorResponse {
    return {};
  },

  toJSON(_: MsgRemoveOperatorResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRemoveOperatorResponse>, I>>(base?: I): MsgRemoveOperatorResponse {
    return MsgRemoveOperatorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRemoveOperatorResponse>, I>>(_: I): MsgRemoveOperatorResponse {
    const message = createBaseMsgRemoveOperatorResponse();
    return message;
  },
};

function createBaseMsgAddCollateral(): MsgAddCollateral {
  return { address: "", collateralIncrement: [] };
}

export const MsgAddCollateral = {
  encode(message: MsgAddCollateral, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.collateralIncrement) {
      Coin.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddCollateral {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddCollateral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.collateralIncrement.push(Coin.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddCollateral {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      collateralIncrement: globalThis.Array.isArray(object?.collateralIncrement)
        ? object.collateralIncrement.map((e: any) => Coin.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgAddCollateral): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.collateralIncrement?.length) {
      obj.collateralIncrement = message.collateralIncrement.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddCollateral>, I>>(base?: I): MsgAddCollateral {
    return MsgAddCollateral.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddCollateral>, I>>(object: I): MsgAddCollateral {
    const message = createBaseMsgAddCollateral();
    message.address = object.address ?? "";
    message.collateralIncrement = object.collateralIncrement?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgAddCollateralResponse(): MsgAddCollateralResponse {
  return {};
}

export const MsgAddCollateralResponse = {
  encode(_: MsgAddCollateralResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddCollateralResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddCollateralResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddCollateralResponse {
    return {};
  },

  toJSON(_: MsgAddCollateralResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddCollateralResponse>, I>>(base?: I): MsgAddCollateralResponse {
    return MsgAddCollateralResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddCollateralResponse>, I>>(_: I): MsgAddCollateralResponse {
    const message = createBaseMsgAddCollateralResponse();
    return message;
  },
};

function createBaseMsgReduceCollateral(): MsgReduceCollateral {
  return { address: "", collateralDecrement: [] };
}

export const MsgReduceCollateral = {
  encode(message: MsgReduceCollateral, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.collateralDecrement) {
      Coin.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgReduceCollateral {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReduceCollateral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.collateralDecrement.push(Coin.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgReduceCollateral {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      collateralDecrement: globalThis.Array.isArray(object?.collateralDecrement)
        ? object.collateralDecrement.map((e: any) => Coin.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgReduceCollateral): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.collateralDecrement?.length) {
      obj.collateralDecrement = message.collateralDecrement.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgReduceCollateral>, I>>(base?: I): MsgReduceCollateral {
    return MsgReduceCollateral.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgReduceCollateral>, I>>(object: I): MsgReduceCollateral {
    const message = createBaseMsgReduceCollateral();
    message.address = object.address ?? "";
    message.collateralDecrement = object.collateralDecrement?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgReduceCollateralResponse(): MsgReduceCollateralResponse {
  return {};
}

export const MsgReduceCollateralResponse = {
  encode(_: MsgReduceCollateralResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgReduceCollateralResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReduceCollateralResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgReduceCollateralResponse {
    return {};
  },

  toJSON(_: MsgReduceCollateralResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgReduceCollateralResponse>, I>>(base?: I): MsgReduceCollateralResponse {
    return MsgReduceCollateralResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgReduceCollateralResponse>, I>>(_: I): MsgReduceCollateralResponse {
    const message = createBaseMsgReduceCollateralResponse();
    return message;
  },
};

function createBaseMsgWithdrawReward(): MsgWithdrawReward {
  return { address: "" };
}

export const MsgWithdrawReward = {
  encode(message: MsgWithdrawReward, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdrawReward {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawReward {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: MsgWithdrawReward): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWithdrawReward>, I>>(base?: I): MsgWithdrawReward {
    return MsgWithdrawReward.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWithdrawReward>, I>>(object: I): MsgWithdrawReward {
    const message = createBaseMsgWithdrawReward();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseMsgWithdrawRewardResponse(): MsgWithdrawRewardResponse {
  return {};
}

export const MsgWithdrawRewardResponse = {
  encode(_: MsgWithdrawRewardResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdrawRewardResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawRewardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgWithdrawRewardResponse {
    return {};
  },

  toJSON(_: MsgWithdrawRewardResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWithdrawRewardResponse>, I>>(base?: I): MsgWithdrawRewardResponse {
    return MsgWithdrawRewardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWithdrawRewardResponse>, I>>(_: I): MsgWithdrawRewardResponse {
    const message = createBaseMsgWithdrawRewardResponse();
    return message;
  },
};

function createBaseMsgCreateTask(): MsgCreateTask {
  return { contract: "", function: "", bounty: [], description: "", creator: "", wait: "0", validDuration: undefined };
}

export const MsgCreateTask = {
  encode(message: MsgCreateTask, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract !== "") {
      writer.uint32(10).string(message.contract);
    }
    if (message.function !== "") {
      writer.uint32(18).string(message.function);
    }
    for (const v of message.bounty) {
      Coin.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.creator !== "") {
      writer.uint32(42).string(message.creator);
    }
    if (message.wait !== "0") {
      writer.uint32(48).int64(message.wait);
    }
    if (message.validDuration !== undefined) {
      Duration.encode(message.validDuration, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateTask {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.function = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bounty.push(Coin.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.wait = longToString(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.validDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateTask {
    return {
      contract: isSet(object.contract) ? globalThis.String(object.contract) : "",
      function: isSet(object.function) ? globalThis.String(object.function) : "",
      bounty: globalThis.Array.isArray(object?.bounty) ? object.bounty.map((e: any) => Coin.fromJSON(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      wait: isSet(object.wait) ? globalThis.String(object.wait) : "0",
      validDuration: isSet(object.validDuration) ? Duration.fromJSON(object.validDuration) : undefined,
    };
  },

  toJSON(message: MsgCreateTask): unknown {
    const obj: any = {};
    if (message.contract !== "") {
      obj.contract = message.contract;
    }
    if (message.function !== "") {
      obj.function = message.function;
    }
    if (message.bounty?.length) {
      obj.bounty = message.bounty.map((e) => Coin.toJSON(e));
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.wait !== "0") {
      obj.wait = message.wait;
    }
    if (message.validDuration !== undefined) {
      obj.validDuration = Duration.toJSON(message.validDuration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateTask>, I>>(base?: I): MsgCreateTask {
    return MsgCreateTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateTask>, I>>(object: I): MsgCreateTask {
    const message = createBaseMsgCreateTask();
    message.contract = object.contract ?? "";
    message.function = object.function ?? "";
    message.bounty = object.bounty?.map((e) => Coin.fromPartial(e)) || [];
    message.description = object.description ?? "";
    message.creator = object.creator ?? "";
    message.wait = object.wait ?? "0";
    message.validDuration = (object.validDuration !== undefined && object.validDuration !== null)
      ? Duration.fromPartial(object.validDuration)
      : undefined;
    return message;
  },
};

function createBaseMsgCreateTaskResponse(): MsgCreateTaskResponse {
  return {};
}

export const MsgCreateTaskResponse = {
  encode(_: MsgCreateTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCreateTaskResponse {
    return {};
  },

  toJSON(_: MsgCreateTaskResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateTaskResponse>, I>>(base?: I): MsgCreateTaskResponse {
    return MsgCreateTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateTaskResponse>, I>>(_: I): MsgCreateTaskResponse {
    const message = createBaseMsgCreateTaskResponse();
    return message;
  },
};

function createBaseMsgTaskResponse(): MsgTaskResponse {
  return { contract: "", function: "", score: "0", operator: "" };
}

export const MsgTaskResponse = {
  encode(message: MsgTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract !== "") {
      writer.uint32(10).string(message.contract);
    }
    if (message.function !== "") {
      writer.uint32(18).string(message.function);
    }
    if (message.score !== "0") {
      writer.uint32(24).int64(message.score);
    }
    if (message.operator !== "") {
      writer.uint32(34).string(message.operator);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.function = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.score = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.operator = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTaskResponse {
    return {
      contract: isSet(object.contract) ? globalThis.String(object.contract) : "",
      function: isSet(object.function) ? globalThis.String(object.function) : "",
      score: isSet(object.score) ? globalThis.String(object.score) : "0",
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
    };
  },

  toJSON(message: MsgTaskResponse): unknown {
    const obj: any = {};
    if (message.contract !== "") {
      obj.contract = message.contract;
    }
    if (message.function !== "") {
      obj.function = message.function;
    }
    if (message.score !== "0") {
      obj.score = message.score;
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgTaskResponse>, I>>(base?: I): MsgTaskResponse {
    return MsgTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgTaskResponse>, I>>(object: I): MsgTaskResponse {
    const message = createBaseMsgTaskResponse();
    message.contract = object.contract ?? "";
    message.function = object.function ?? "";
    message.score = object.score ?? "0";
    message.operator = object.operator ?? "";
    return message;
  },
};

function createBaseMsgTaskResponseResponse(): MsgTaskResponseResponse {
  return {};
}

export const MsgTaskResponseResponse = {
  encode(_: MsgTaskResponseResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgTaskResponseResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTaskResponseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTaskResponseResponse {
    return {};
  },

  toJSON(_: MsgTaskResponseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgTaskResponseResponse>, I>>(base?: I): MsgTaskResponseResponse {
    return MsgTaskResponseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgTaskResponseResponse>, I>>(_: I): MsgTaskResponseResponse {
    const message = createBaseMsgTaskResponseResponse();
    return message;
  },
};

function createBaseMsgDeleteTask(): MsgDeleteTask {
  return { contract: "", function: "", force: false, from: "" };
}

export const MsgDeleteTask = {
  encode(message: MsgDeleteTask, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contract !== "") {
      writer.uint32(10).string(message.contract);
    }
    if (message.function !== "") {
      writer.uint32(18).string(message.function);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    if (message.from !== "") {
      writer.uint32(34).string(message.from);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteTask {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contract = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.function = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.from = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteTask {
    return {
      contract: isSet(object.contract) ? globalThis.String(object.contract) : "",
      function: isSet(object.function) ? globalThis.String(object.function) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
      from: isSet(object.from) ? globalThis.String(object.from) : "",
    };
  },

  toJSON(message: MsgDeleteTask): unknown {
    const obj: any = {};
    if (message.contract !== "") {
      obj.contract = message.contract;
    }
    if (message.function !== "") {
      obj.function = message.function;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteTask>, I>>(base?: I): MsgDeleteTask {
    return MsgDeleteTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteTask>, I>>(object: I): MsgDeleteTask {
    const message = createBaseMsgDeleteTask();
    message.contract = object.contract ?? "";
    message.function = object.function ?? "";
    message.force = object.force ?? false;
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseMsgDeleteTaskResponse(): MsgDeleteTaskResponse {
  return {};
}

export const MsgDeleteTaskResponse = {
  encode(_: MsgDeleteTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeleteTaskResponse {
    return {};
  },

  toJSON(_: MsgDeleteTaskResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteTaskResponse>, I>>(base?: I): MsgDeleteTaskResponse {
    return MsgDeleteTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteTaskResponse>, I>>(_: I): MsgDeleteTaskResponse {
    const message = createBaseMsgDeleteTaskResponse();
    return message;
  },
};

function createBaseMsgCreateTxTask(): MsgCreateTxTask {
  return { creator: "", chainId: "", atxBytes: new Uint8Array(0), bounty: [], validTime: undefined };
}

export const MsgCreateTxTask = {
  encode(message: MsgCreateTxTask, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.atxBytes.length !== 0) {
      writer.uint32(26).bytes(message.atxBytes);
    }
    for (const v of message.bounty) {
      Coin.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.validTime !== undefined) {
      Timestamp.encode(toTimestamp(message.validTime), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateTxTask {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateTxTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.atxBytes = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bounty.push(Coin.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.validTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateTxTask {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      atxBytes: isSet(object.atxBytes) ? bytesFromBase64(object.atxBytes) : new Uint8Array(0),
      bounty: globalThis.Array.isArray(object?.bounty) ? object.bounty.map((e: any) => Coin.fromJSON(e)) : [],
      validTime: isSet(object.validTime) ? fromJsonTimestamp(object.validTime) : undefined,
    };
  },

  toJSON(message: MsgCreateTxTask): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.atxBytes.length !== 0) {
      obj.atxBytes = base64FromBytes(message.atxBytes);
    }
    if (message.bounty?.length) {
      obj.bounty = message.bounty.map((e) => Coin.toJSON(e));
    }
    if (message.validTime !== undefined) {
      obj.validTime = message.validTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateTxTask>, I>>(base?: I): MsgCreateTxTask {
    return MsgCreateTxTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateTxTask>, I>>(object: I): MsgCreateTxTask {
    const message = createBaseMsgCreateTxTask();
    message.creator = object.creator ?? "";
    message.chainId = object.chainId ?? "";
    message.atxBytes = object.atxBytes ?? new Uint8Array(0);
    message.bounty = object.bounty?.map((e) => Coin.fromPartial(e)) || [];
    message.validTime = object.validTime ?? undefined;
    return message;
  },
};

function createBaseMsgCreateTxTaskResponse(): MsgCreateTxTaskResponse {
  return { atxHash: new Uint8Array(0) };
}

export const MsgCreateTxTaskResponse = {
  encode(message: MsgCreateTxTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.atxHash.length !== 0) {
      writer.uint32(10).bytes(message.atxHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateTxTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateTxTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.atxHash = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateTxTaskResponse {
    return { atxHash: isSet(object.atxHash) ? bytesFromBase64(object.atxHash) : new Uint8Array(0) };
  },

  toJSON(message: MsgCreateTxTaskResponse): unknown {
    const obj: any = {};
    if (message.atxHash.length !== 0) {
      obj.atxHash = base64FromBytes(message.atxHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateTxTaskResponse>, I>>(base?: I): MsgCreateTxTaskResponse {
    return MsgCreateTxTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateTxTaskResponse>, I>>(object: I): MsgCreateTxTaskResponse {
    const message = createBaseMsgCreateTxTaskResponse();
    message.atxHash = object.atxHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgTxTaskResponse(): MsgTxTaskResponse {
  return { atxHash: new Uint8Array(0), score: "0", operator: "" };
}

export const MsgTxTaskResponse = {
  encode(message: MsgTxTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.atxHash.length !== 0) {
      writer.uint32(10).bytes(message.atxHash);
    }
    if (message.score !== "0") {
      writer.uint32(16).int64(message.score);
    }
    if (message.operator !== "") {
      writer.uint32(26).string(message.operator);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgTxTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTxTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.atxHash = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.score = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operator = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTxTaskResponse {
    return {
      atxHash: isSet(object.atxHash) ? bytesFromBase64(object.atxHash) : new Uint8Array(0),
      score: isSet(object.score) ? globalThis.String(object.score) : "0",
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
    };
  },

  toJSON(message: MsgTxTaskResponse): unknown {
    const obj: any = {};
    if (message.atxHash.length !== 0) {
      obj.atxHash = base64FromBytes(message.atxHash);
    }
    if (message.score !== "0") {
      obj.score = message.score;
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgTxTaskResponse>, I>>(base?: I): MsgTxTaskResponse {
    return MsgTxTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgTxTaskResponse>, I>>(object: I): MsgTxTaskResponse {
    const message = createBaseMsgTxTaskResponse();
    message.atxHash = object.atxHash ?? new Uint8Array(0);
    message.score = object.score ?? "0";
    message.operator = object.operator ?? "";
    return message;
  },
};

function createBaseMsgTxTaskResponseResponse(): MsgTxTaskResponseResponse {
  return {};
}

export const MsgTxTaskResponseResponse = {
  encode(_: MsgTxTaskResponseResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgTxTaskResponseResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTxTaskResponseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTxTaskResponseResponse {
    return {};
  },

  toJSON(_: MsgTxTaskResponseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgTxTaskResponseResponse>, I>>(base?: I): MsgTxTaskResponseResponse {
    return MsgTxTaskResponseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgTxTaskResponseResponse>, I>>(_: I): MsgTxTaskResponseResponse {
    const message = createBaseMsgTxTaskResponseResponse();
    return message;
  },
};

function createBaseMsgDeleteTxTask(): MsgDeleteTxTask {
  return { atxHash: new Uint8Array(0), from: "" };
}

export const MsgDeleteTxTask = {
  encode(message: MsgDeleteTxTask, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.atxHash.length !== 0) {
      writer.uint32(10).bytes(message.atxHash);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteTxTask {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteTxTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.atxHash = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteTxTask {
    return {
      atxHash: isSet(object.atxHash) ? bytesFromBase64(object.atxHash) : new Uint8Array(0),
      from: isSet(object.from) ? globalThis.String(object.from) : "",
    };
  },

  toJSON(message: MsgDeleteTxTask): unknown {
    const obj: any = {};
    if (message.atxHash.length !== 0) {
      obj.atxHash = base64FromBytes(message.atxHash);
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteTxTask>, I>>(base?: I): MsgDeleteTxTask {
    return MsgDeleteTxTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteTxTask>, I>>(object: I): MsgDeleteTxTask {
    const message = createBaseMsgDeleteTxTask();
    message.atxHash = object.atxHash ?? new Uint8Array(0);
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseMsgDeleteTxTaskResponse(): MsgDeleteTxTaskResponse {
  return {};
}

export const MsgDeleteTxTaskResponse = {
  encode(_: MsgDeleteTxTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteTxTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteTxTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeleteTxTaskResponse {
    return {};
  },

  toJSON(_: MsgDeleteTxTaskResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteTxTaskResponse>, I>>(base?: I): MsgDeleteTxTaskResponse {
    return MsgDeleteTxTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteTxTaskResponse>, I>>(_: I): MsgDeleteTxTaskResponse {
    const message = createBaseMsgDeleteTxTaskResponse();
    return message;
  },
};

/** Msg defines the shield Msg service. */
export interface Msg {
  CreateOperator(request: MsgCreateOperator): Promise<MsgCreateOperatorResponse>;
  RemoveOperator(request: MsgRemoveOperator): Promise<MsgRemoveOperatorResponse>;
  AddCollateral(request: MsgAddCollateral): Promise<MsgAddCollateralResponse>;
  ReduceCollateral(request: MsgReduceCollateral): Promise<MsgReduceCollateralResponse>;
  WithdrawReward(request: MsgWithdrawReward): Promise<MsgWithdrawRewardResponse>;
  CreateTask(request: MsgCreateTask): Promise<MsgCreateTaskResponse>;
  TaskResponse(request: MsgTaskResponse): Promise<MsgTaskResponseResponse>;
  DeleteTask(request: MsgDeleteTask): Promise<MsgDeleteTaskResponse>;
  CreateTxTask(request: MsgCreateTxTask): Promise<MsgCreateTxTaskResponse>;
  TxTaskResponse(request: MsgTxTaskResponse): Promise<MsgTxTaskResponseResponse>;
  DeleteTxTask(request: MsgDeleteTxTask): Promise<MsgDeleteTxTaskResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
